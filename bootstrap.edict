[
]@newline

[LTV_concat!]@concat

[compile_ltv(@code jit_edict code)]@compile
[[a b c] compile compile!!! locals!]@test_compile

[try(cif_preview_module!)]@preview
[try(cif_curate_module(0))]@import
[[preview(lib) import(lib) lib](@lib)]@loadlib

[loadlib([test/build/libtestlib.so]) @test test.y.1 stack!]@testimport
[loadlib([/home/jnyberg/htm/build/libhtmlib.so]) @htm htm.init(0 0)]@testimport2
[loadlib([/home/jnyberg/htm/build/libhtmlib.so]) <init(0 0)>]@testimport3

[bench encaps! vm_while! | locals!]@fastbench
[bench [dup! ! loop!]@loop loop! | locals!]@midbench

[a b int_add! /@a a limit int_nequal! slowloop!]@slowloop
[int! @@limit 0 int! @@a 1 int! @@b slowloop! | locals!]@slowbench

[pthread_t! @thread vm_thread_create(thread) ! thread | /thread]@async

[vm_thunk! vm_create_cb([vm_thunk] ENV.ROOT [square(Arg0) encaps! RETURN@]) @ @thunk
async(thunk 3) @thread [waiting...] stack!/ thread await! stack!]@test_async_await

[vm_eval(ROOT [ROOT<ARG0 decaps! stack! ! encaps! RETURN @>] [square(3)])]@async_test1

[
encaps(vm_continuation(encaps('(LTV)*(*)((LTV)*)') ROOT [ROOT<ARG0 stack! RETURN @>]))@cont
vm_async(cont encaps([square(3)]))@taskA
encaps(vm_await(taskA))
stack!
]@async_test2

[
encaps(vm_continuation(encaps('(void)*(*)((void)*)') ROOT [ROOT<ARG0 stack! RETURN @>]))@contA
vm_async(contA 3)@taskA
vm_await(taskA)@intermediate

encaps(vm_continuation(encaps('(void)*(*)((void)*)') ROOT [ROOT<ARG0 'long long int'!@ stack! RETURN @>]))@contB
vm_async(contB intermediate)@taskB vm_await(taskB)

stack!
]@async_test3


async_test3!

repl(get_stdin!)
